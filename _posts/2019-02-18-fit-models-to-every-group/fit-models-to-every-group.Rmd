---
title: "Complete vs. partial vs. no-pooling: Fit the same model to different groups (just one simple line of code)"
description: |
  What is complete pooling, no-pooling, and partial pooling, and how to use data.table for no-pooling models (fit the same model, but separately to each group)
author:
  - name: Hause Lin
date: 02-18-2019
output:
  radix::radix_article:
    toc: true
    self_contained: false
draft: false
categories: 
  - data.table
  - pooling
  - hausekeep
repository_url: https://github.com/hauselin/rtutorialsite/blob/master/_posts/2019-02-18-fit-models-to-every-group/fit-models-to-every-group.Rmd
bibliography: biblio.bib
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(roxygen2)
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, comment = NA, message = FALSE, warning = FALSE, R.options = list(width = 80))
```

Get source code for this RMarkdown script [here](https://github.com/hauselin/rtutorialsite/blob/master/_posts/2019-02-18-fit-models-to-every-group/fit-models-to-every-group.Rmd).

## How to use `data.table` package to repeatedly fit a model to separate groups in a dataset

Before the invention of multi-level models (aka linear mixed effects models), how did people analyze nested or repeated-measures data? They aggregated the data, used repeated-measures ANOVA, and did other things. 

One interesting approach is to repeatedly fit the same model to each group separately, and this approach seems to be first mentioned in this article [@Lorch]. If you have 10 data points per subject, you have nested data (data points nested within subjects), and you could fit 10 linear regressions, one for each subject. This approach is still quite useful nowadays (I use it regularly in my research), and I'll demonstrate how to do it easily with `data.table` and my `summaryh()` function from my `hausekeep` package. 

```{r}
# load packages
library(hausekeep); library(data.table)
```

Convert the built-in dataset `ChickWeight` to `data.table` class so we can leverage its extensive functionalities. 

```{r} 
dt1 <- data.table(ChickWeight) # convert builtin dataset to data.table class
dt1 # print dataset 
```

<aside>
Dataset contains weights of 50 chicks that were fed one of four diets. Their weights were tracked over time. Type `?ChickWeight` in the console for more info about this dataset.
</aside>

## Completing pooling approach

Let's look at just the first 5 chicks (and to illustrate `data.table` syntax; see my [data.table](https://hausetutorials.netlify.com/0002_tidyverse_datatable.html) tutorials). We then fit a linear regression `weight ~ Time` to the data from these 5 chicks, ignoring that the data came from 5 different chicks (i.e., completing pooling).  That is, we pretend all the data came from one chick.

```{r}
# filter rows where Chick is <= 5 and fit linear regression model
dt1[Chick <= 5, ] # syntax works only with data.table
model <- lm(weight ~ Time, data = dt1[Chick <= 5])
summary(model)
```

Show formatted output that can be copied-pasted into your APA manuscript.

```{r}
summaryh(model) 
```

Or fit the same model within `data.table`

```{r}
dt1[Chick <= 5, summaryh(lm(weight ~ Time))] # results are same as above
```

<aside>
`summaryh()` returns results in a `data.table`.
</aside>

## Partial pooling approach

The more appropriate way to fit this model is to account for the nested structure is to use linear mixed models (lme4 package): `lmer(weight ~ Time + (1 | Chick), data = dt1[Chick <= 5])`. This approach is 'partial pooling', because it assumes hierarchy in the data structure.

```{r}
library(lme4); library(lmerTest)
lme1 <- lmer(weight ~ Time + (1 | Chick), data = dt1[Chick %in% 1:5])
summaryh(lme1)
summary(lme1)
```

## No pooling approach

What if you want to fit a separate model for each chick/group, so you know how time was associated with weight for each chick? You could write a for loop to loop through each chick, but you can do it with `data.table` syntax really easily. 

Now we can extend the syntax above with `by = Chick` to fit the model to each chick! Just one line of code is needed.

```{r}
# fit linear regression model to first 5 Chicks
dt1[Chick %in% 1:5, summaryh(lm(weight ~ Time)), by = Chick]
```
<aside>
When calling functions inside a `data.table` with the `by` argument, your functions have to return vectors, lists, or dataframes. Otherwise, you'll get error messages. Run the code below to figure out why.
</aside>

Why won't `summary()` work?

```{r
dt1[Chick <= 5, summary(lm(weight ~ Time))] # summary() doesn't return a table
dt1[Chick <= 5, summary(lm(weight ~ Time)), by = Chick] # doesn't work! 
```

You can also use the `lmList()` function from the `lme4` package to fit this 'no-pooling' model, but you don't get p-values, effect sizes, and other useful information!

```{r}
dt2 <- dt1[Chick %in% 1:5]
lmList(weight ~ Time | Chick, data = dt2)
```
